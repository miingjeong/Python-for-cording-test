# 그리디 알고리즘

-그리디 알고리즘(탐욕법)은 현재 상황에서 지금 당장 좋은 것만 고르는 방법을 의미합니다.

-일반적인 그리디 알고리즘은 문제를 풀기 위한 최소한의 아이디어를 떠올릴 수 있는 능력을 요구합니다. 

-그리디 해법은 그 정당성 분석이 중요합니다
  
  -단순히 가장 좋아 보이는 것을 반복적으로 선택해도 최적의 해를 구할 수 있는 지 검토합니다. 

-일반적인 상황에서 그리디 알고리즘은 최적의 해를 보장할 수 없을 때가 많습니다.

-하지만 코딩 테스트에서 대부분의 그리디 문제는 탐욕법으로 얻은 해가 최적의 해가 되는 상황에서, 이를 추론할 수 있어야 풀리도록 출제됩니다.

---



&#9989;문제&#9989;

### 거스름 돈
```

당신은 음식점의 계산을 도와주는 점원입니다. 카운터에는 거스름돈으로 사용할 500원, 100원, 50원, 10원짜리 동전이 무한히 존재한다고 가정합니다. 손님에게 거슬러 주어야 할 돈이 N원일 때 거슬러 주어야 할 동전의 최소 개수를 구하세요. 단, 거슬로 줘야 할 돈 N은 항상 10의 배수입니다. 

``` 


````python
n=1260
count=0
#큰 단위의 화폐부터 차례대로 확인
array[500,100,50, 10]

for coin in array:
    count+=n//coin #해당 화폐로 거슬러 줄 수 있는 동전의 개수 세기
    n%=coin
print(count)

````



&#9989;문제&#9989;

### 1이 될때까지:

````
어떠한 수 N이 1이 될 때까지 다음의 두 과정 중 하나를 반복적으로 선택하여 수행합니다. 단 두번째 연산은 N이 K로 나누어 떨어질 때만 선택할 수 있습니다.
1. N에서 1을 뺀다
2. N을 K로 나눈다.
````
 풀이 

 -주어진 N에 대하여 최대한 많이 나누기를 수행하면 된다.

 -N의 값을 줄일 때 2 이상의 수로 나누는 작업이 1을 빼는 작업보다 수를 훨씬 줄일 수 있다.

````python
#N, K을 공백을 기준으로 구분하여 입력 받기
n, k= map(int, input().split())

result=0
while True:
    #N이 K로 나누어 떨어지는 수가 될 때까지 빼기
    target=(n//k)*k
    result +=(n-target)
    n=target
    #N이 K보다 작을 때(더이상 나눌 수 없을 때) 반복문 탈출
    if n<k:
        break
    #K로 나누기
    result+=1
    n//=k
#마지막으로 남은 수에 대하여 1씩 뺴기
result+=(n-1)
print(result)
````



&#9989;문제&#9989;

### 곱하기 혹은 더하기 문제:

```
각 자리가 숫자(0부터 9)로만 이루어진 문자열 S가 주어졌을 때, 왼쪽부터 오른쪽으로 하나씩 모든 숫자를 확인하며 숫자 사이에 'x' 혹은 '+'연산자를 넣어 결과적으로 만들어질 수 있는 가장 큰 수를 구하는 프로그램을 작성하시오. 단 +보다 x를 먼저 계산하는 일반적인 방식과는 달리, 모든 연산은 왼쪽에서부터 순서대로 이루어진다고 가정합니다.
```

대부분의 경우 '+' 보다 'x'가 더 값을 크게 만든다.

다만 두 수중에서 하나라도 '0'혹은 '1'인 경우, 곱하기보다는 더하기를 수행하는 것이 효율적이다. 

````python

data=input()

#첫 번째 문자를 숫자로 변경하여 대입
result=int(data[0])

for i in range(1, len(data)):
    #두 수중에서 하나라도 '0' 혹은 '1'인경우, 곱하기 보다는 더하기 수행
    num=int(data[i])
    if num<=1 orresult <=1:
        result+=num
    else:
        result *= num
print(result)
````

&#9989;문제&#9989;

### 모험가 길드:

````
한 마을에 모험가가 N명 있습니다. 모험가 길드에서는 N명의 모험가를 대상으로 '공포도'를 측정했는데, '공포도'가 높은 모험가는 쉽게 공포를 느껴 위험 상황에서 제대로 대처할 능력이 떨어집니다.
모험가 길드장인 동빈이는 모험가 그룹을 안전하게 구성하고자 공포도가 x인 모험가는 반드시 x명 이상으로 구성한 모험가 그룹에 참여해야 여행을 떠날 수 있도록 규정했습니다. 
동빈이는 최대 몇 개의 모험가 그룹을 만들 수 있는지 궁금합니다. N명의 모험가에 대한 정보가 주어졌을 때, 여행을 떠날 수 있는 그룹 수의 최댓값을 구하는 프로그램을 작성하세요.
````

````python
n=int(input())
data=list(map(int, input().split()))
data.sort()

result=0 #총 그룹의 수
count=0 #현재 그룹에 포함된 모험가의 수

for i in data: #공포도를 낮은 것부터 하나씩 확인하며
    count+=1 #현재 그룹에 해당 모험가를 포함시키기
    if count>=i: #현재 그룹에 포함된 모험가의 수가 현재의 공포도 이상이라면, 그룹 결성
    result +=1 #총 그룹의 수 증가시키기
    count=0 #현재 그룹에 포함된 모험가의 수 초기화
print(result) #총 그룹의 수 출력
````

# 구현
구현이란, 머릿속에 있는 알고리즘을 소스코드로 바꾸는 과정

-풀이를 떠올리는 것은 쉽지만 소스 코드로 옮기기 어려운 문제를 지칭합니다.

구현의 예시

-알고리즘은 간단한데 코드가 지나칠 만큼 길어지는 문제

-실수 연산을 다루고, 특정 소수점 자리까지 출력해야 하는 문제

-문자열을 특정한 기준에 따라서 끊어 처리해야 하는 문제

-적절한 라이브러리를 찾아서 사용해야 하는 문제


일반적으로 알고리즘 문제엥서 2차원 공간은 행렬(Matrix)의 의미로 사용됩니다.

```python
for i in range(5):
    for j in range(5):
        print('(',i,',',j,')',end=' ')
    print()

```

시뮬레이션 및 완전 탐색 문제에서는 2차원 공간에서의 방향 벡터가 자주 사용됩니다.

```python
#동, 북 , 서 남
dx=[0,-1, 0, 1]
dy=[1,0,-1, 0]

#현재 위치
x, y=2,2

for i in range(4):
    #다음위치
    nx=x+dx[i]
    ny=y+dy[i]
    print(nx, ny)

```

&#9989;문제&#9989;

### 상하좌우

```
여행가 A는 NxN크기의 정사각형 공간 위에 서 있습니다. 이 공간은 1x1 크기의 정사각형으로 나누어져 있습니다. 가장 왼쪽 위 좌표는 (1,1)이며, 가장 오른쪽 아래 죄표는 (N, N)에 해당합니다. 여행가는 상, 하, 좌, 우 방향으로 이동할 수 있으며, 시작 좌표는 항상(1,1)입니다. 우리 앞에는 여행가 A가 이동할 계획이 적힌 계획서가 놓여있습니다.
계획서에는 하나의 줄에 띄어쓰기를 기준으로 하여 L,R,U,D중 하나의 문자가 반복적으로 적혀 있습니다.

-L : 왼쪽으로 한칸 이동

-R: 오른쪽으로 한칸 이동

- U : 위로 한칸 이동

-D: 아래로 한칸 이동

```

````python
#입력 받기
n=int(input())
x, y = 1, 1
plans=input().split()

#L, R, U, D에 따른 이동 방향
dx=[0,0,-1,-1]
dy=[-1, 1, 0 , 0]
move_types=['L','R','U','D']

#이동 계획을 하나씩 확인하기
for plan in plans:
    #이동 후 좌표 구하기
    for i in range(len(move_types)):
        if plan==move_types[i]:
            nx=x+dx[i]
            ny=y+dy[i]
    #공간을 벗어나는 경우 무시
    if nx < 1 or ny < 1 or nx > n or ny >n:
        continue
        #이동 수행
        x, y = nx, ny
print(x, y)
````

&#9989;문제&#9989;

### 시각

```
정수 N이 입력되면 00시 00분 00초 부터 N시 59분 59초까지 모든 시각 중에서 3이 하나라도 포함되는 모든 경우의 수를 구하는 프로그램을 작성하시오.

```

완전 탐색 문제 유형이라 불림. (가능한 경우의 수를 모두 검사해 보는 탐색 방법)

````python
h=int(input())

count=0
for i in range(h+1):
    for j in range(60):
        for k in range(60):
            #매 시각 안에 '3' 포함되어 있으면 카운트 증가
            if '3' in str(i)+str(j)+str(k):
                count+=1
print(count)
````
&#9989;문제&#9989;

### 왕실의 나이트


````
행복 왕국 왕실 정원은 체스판과 같은 8*8 좌표 평면입니다. 왕실 정원의 특정한 한 칸에 나이트가 서 있습니다. 나이트는 매우 충성스러운 신하로서 매일 무술을 연마합니다. 나이트는 말을타고 있기 대문에 L형태로만 이동할 수 있습니다. 정원 나가기 x
나이트는 특정 위치에서 다음과 같은 2가지 경우로 이동할 수 있습니다.
1. 수평으로 두칸 이동 후 수직으로 한칸 이동
2. 수직으로 두칸 이동한 뒤 수평으로 한칸 이동
````

나이트의 8가지 경로를 하나씩 확인하며 각 위치로 이동이 가능한지 확인합니다

리스트를 이용하여 8가지 방향에 대한 벡터를 정의합니다. 

````python
# 현재 나이트의 위치 입력받기
input_data = input()
row = int(input_data[1])
column = int(ord(input_data[0])) - int(ord('a')) + 1

# 나이트가 이동할 수 있는 8가지 방향 정의
steps = [(-2, -1), (-1, -2), (1, -2), (2, -1), (2, 1), (1, 2), (-1, 2), (-2, 1)]

# 8가지 방향에 대하여 각 위치로 이동이 가능한지 확인
result = 0
for step in steps:
    # 이동하고자 하는 위치 확인
    next_row = row + step[0]
    next_column = column + step[1]
    # 해당 위치로 이동이 가능하다면 카운트 증가
    if next_row >= 1 and next_row <= 8 and next_column >= 1 and next_column <= 8:
        result += 1

print(result)
````

&#9989;문제&#9989;

### 문자열 재정렬

```
문자열 입력되었을 때 문자를 하나씩 확인한다.
숫자일경우 따로 합계를 계산합니다.
알파벳은 경우 별도의 리스트에 저장

결과적으로 ** 리스트에 저장된 알파벳을 정렬해 출력하고 , 합계를 뒤에 붙여 출력하면 정답 **
```

````python
data=input()
result=[]
value=0

for x in data:
    if x.isalpha():
        result.append(x)
    else:
        value+=int(x)
result.sort()

if value !=0:
    result.append(str(value))
print(''.join(result))

````
